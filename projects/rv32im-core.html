<!DOCTYPE html>
<html lang="en">
    
<head>
<meta charset="UTF-8">
<title>RV32IM Core: A Single-Cycle RISC-V Processor</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../css/main.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
</head>

<body>
<header>
<div class="container">
<nav>
<div class="links">
<a href="../index.html">/home</a>
<a href="../photos.html">/photos</a>
<a href="../projects.html">/projects</a>
</div>
<div class="social-links">
<a href="https://github.com/cigi10" target="_blank" aria-label="GitHub" title="GitHub">
<i class="fab fa-github"></i>
</a>
<a href="https://in.linkedin.com/in/prachi-gore-604416294" target="_blank" aria-label="LinkedIn" title="LinkedIn">
<i class="fab fa-linkedin-in"></i>
</a>
<a href="mailto:you@example.com" aria-label="Email" title="Email">
<i class="fas fa-envelope"></i>
</a>
</div>
</nav>
</div>
</header>

<main>
  <div class="container blog-content">
    <h1>/rv32im-core</h1>

    <p style="opacity: 0.7; font-size: 0.95em; margin-bottom: 2em;">
      <i class="fas fa-calendar"></i> January 2026 &nbsp;|&nbsp;
      <i class="fas fa-tag"></i> SystemVerilog, RISC-V, Digital Design &nbsp;|&nbsp;
      <i class="fas fa-clock"></i> 12 min read
    </p>

    <div class="note">
      <strong>TL;DR:</strong> A complete single-cycle RISC-V processor implementing the RV32IM instruction set in SystemVerilog. Synthesizes successfully on Xilinx Artix-7 FPGA (Basys 3 board) with 12 DSP blocks for hardware multiplication/division and 1 BRAM for instruction memory. Built from scratch to understand processor architecture at the RTL level.
    </div>

    <h2>Introduction</h2>

    <p>
      This is a single-cycle RISC-V processor core supporting the RV32I base integer instruction set plus the M extension (integer multiplication and division). Every instruction completes in exactly one clock cycle. There's no pipelining, no caching, no branch prediction—just a straightforward implementation of the RISC-V specification.
    </p>

    <p>
      The entire design is ~500 lines of SystemVerilog across 11 modules. It synthesizes cleanly on real FPGA hardware and runs a simple test program that counts up on LEDs.
    </p>

    <h2>Architecture</h2>

    <p>
      The core follows the classic five-stage conceptual model (Fetch, Decode, Execute, Memory, Write-back), but executes everything combinationally in a single clock cycle. The datapath looks like this:
    </p>

    <img src="../images/rv32im/datapath_idea.jpeg" alt="RV32IM single-cycle datapath">
    <p style="text-align: center; font-size: 0.9em; color: #666;">
      Complete datapath showing instruction fetch, decode, execution, memory access, and write-back in one cycle.
    </p>

    <h3>Component Breakdown</h3>

    <p><strong>Program Counter (PC):</strong> Holds the address of the current instruction. Updates on every clock edge based on whether we're branching, jumping, or just advancing to PC+4.</p>

    <p><strong>Instruction Memory:</strong> 1KB RAM storing 256 instructions. Synthesizes as Block RAM on FPGA. Currently hardcoded with a test program that increments register x1 in a loop.</p>

    <p><strong>Decoder:</strong> Extracts instruction fields (opcode, registers, immediates, function codes) and determines what operation to perform. Handles all six RISC-V instruction formats (R, I, S, B, U, J).</p>

    <p><strong>Control Unit:</strong> Generates control signals based on opcode. Decides whether to write registers, access memory, select ALU inputs, take branches, or handle jumps.</p>

    <p><strong>Register File:</strong> 32 general-purpose registers (x0-x31) where x0 is hardwired to zero. Two read ports for source operands, one write port for results. Built from flip-flops, not RAM.</p>

    <p><strong>ALU:</strong> Arithmetic Logic Unit performing 16 different operations including ADD, SUB, AND, OR, XOR, shifts, comparisons, and all M-extension operations (MUL, MULH, MULHU, MULHSU, DIV, DIVU, REM, REMU). The multipliers map to DSP48 blocks on the FPGA.</p>

    <p><strong>Branch Unit:</strong> Separate comparator for branch decisions (BEQ, BNE, BLT, BGE, BLTU, BGEU). Compares register values and signals whether to take the branch.</p>

    <p><strong>Data Memory:</strong> 1KB RAM for load/store instructions. Word-addressed (ignores bottom 2 bits). Currently used for storing intermediate computation results.</p>

    <p><strong>PC Control:</strong> Multiplexer selecting next PC value. Priority order: JALR target → JAL target → Branch target → PC+4.</p>

    <h2>Instruction Set Coverage</h2>

    <p>The core implements 47 instructions across multiple categories:</p>

    <table>
      <thead>
        <tr>
          <th>Category</th>
          <th>Instructions</th>
          <th>Count</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Arithmetic (R-type)</strong></td>
          <td>ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND</td>
          <td>10</td>
        </tr>
        <tr>
          <td><strong>Arithmetic (I-type)</strong></td>
          <td>ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRAI</td>
          <td>9</td>
        </tr>
        <tr>
          <td><strong>Load</strong></td>
          <td>LB, LH, LW, LBU, LHU</td>
          <td>5</td>
        </tr>
        <tr>
          <td><strong>Store</strong></td>
          <td>SB, SH, SW</td>
          <td>3</td>
        </tr>
        <tr>
          <td><strong>Branch</strong></td>
          <td>BEQ, BNE, BLT, BGE, BLTU, BGEU</td>
          <td>6</td>
        </tr>
        <tr>
          <td><strong>Jump</strong></td>
          <td>JAL, JALR</td>
          <td>2</td>
        </tr>
        <tr>
          <td><strong>Upper Immediate</strong></td>
          <td>LUI, AUIPC</td>
          <td>2</td>
        </tr>
        <tr>
          <td><strong>M Extension</strong></td>
          <td>MUL, MULH, MULHSU, MULHU, DIV, DIVU, REM, REMU</td>
          <td>8</td>
        </tr>
      </tbody>
    </table>

    <h2>Key Design Decisions</h2>

    <h3>Why Single-Cycle?</h3>
    <p>
      Single-cycle designs are inefficient—every instruction must complete in the time it takes for the slowest instruction (usually a load from memory). But they're conceptually simple. There are no pipeline hazards, no forwarding logic, no stall conditions to debug. The entire processor state updates atomically on every clock edge.
    </p>

    <p>
      For learning processor architecture, single-cycle is perfect. Once you understand this, pipelining is just an optimization.
    </p>

    <h3>Immediate Encoding Complexity</h3>
    <p>
      RISC-V immediate values are scattered across the instruction word in non-intuitive positions. The decoder needs to extract and sign-extend them correctly:
    </p>

    <ul>
      <li><strong>I-type:</strong> imm[11:0] = inst[31:20]</li>
      <li><strong>S-type:</strong> imm[11:0] = {inst[31:25], inst[11:7]}</li>
      <li><strong>B-type:</strong> imm[12:1] = {inst[31], inst[7], inst[30:25], inst[11:8]}</li>
      <li><strong>U-type:</strong> imm[31:12] = inst[31:12]</li>
      <li><strong>J-type:</strong> imm[20:1] = {inst[31], inst[19:12], inst[20], inst[30:21]}</li>
    </ul>

    <p>
      Getting these bit positions wrong leads to subtle bugs where instructions execute but compute wrong addresses or offsets. I spent hours debugging a JAL instruction that was jumping to the wrong location because bit 20 was in the wrong position.
    </p>

    <h3>M Extension Implementation</h3>
    <p>
      The M extension adds 8 multiplication and division instructions. Naive software implementations would take dozens of cycles. The FPGA has dedicated DSP48E1 blocks that can multiply 18×25 bits in a single cycle.
    </p>

    <p>
      Vivado automatically infers DSP blocks when it sees multiplication operators. The synthesis report shows 12 DSP blocks used—multiple instances because 32×32 multiplication requires cascading multiple DSPs together.
    </p>

    <pre><code>DSP Report: Generating DSP alu_result0, operation Mode is: A*B.
DSP Report: operator alu_result0 is absorbed into DSP alu_result0.
DSP Report: Generating DSP alu_result0, operation Mode is: (PCIN>>17)+A*B.
...</code></pre>

    <p>
      Division is trickier. SystemVerilog's <code>/</code> and <code>%</code> operators synthesize to sequential logic that takes multiple cycles. For a single-cycle design, this means division instructions have a long critical path. In a real implementation, you'd either pipeline division or trap to software.
    </p>

    <h3>Register x0 Hardwiring</h3>
    <p>
      RISC-V specifies that register x0 always reads as zero and writes to it are discarded. The register file enforces this:
    </p>

    <pre><code>always @(posedge clk) begin
    if (reg_write == 1'b1 && write_register != 5'b0) begin
        Registers[write_register] <= write_data;
    end
end</code></pre>

    <p>
      The condition <code>write_register != 5'b0</code> prevents writes to x0. Reading x0 naturally returns zero because it's never written.
    </p>

    <h2>Synthesis Results</h2>

    <div class="results-box">
      <h3 style="margin-top: 0;">Xilinx Artix-7 (xc7a35tcpg236-1)</h3>
      <p><strong>Target Board:</strong> Basys 3</p>
      <p><strong>Synthesis Time:</strong> 35 seconds</p>
      <p><strong>Resource Utilization:</strong></p>
      <ul>
        <li>LUTs: 44 (< 1%)</li>
        <li>Flip-flops: 16 (< 1%)</li>
        <li>BRAM (RAMB18E1): 1 (1%)</li>
        <li>DSP48E1 blocks: 12 (13%)</li>
        <li>Total design size: 2.3 MB</li>
      </ul>
    </div>

    <img src="../images/rv32im/synthesis_utilization.png" alt="Synthesis utilization report">
    <p style="text-align: center; font-size: 0.9em; color: #666;">
      Resource utilization on Xilinx Artix-7 FPGA
    </p>

    <h3>Why So Small?</h3>
    <p>
      Most of the "design" is actually memory arrays. The instruction memory (1KB) and data memory (1KB) synthesize to Block RAM. The register file (32×32-bit registers) becomes distributed RAM built from LUTs. The actual control logic—the ALU, decoders, muxes—is tiny.
    </p>

    <p>
      The 12 DSP blocks handle all multiplication/division operations. Each DSP48E1 can perform 25×18 multiply-accumulate operations. Cascading multiple DSPs gives you wider multipliers.
    </p>

    <img src="../images/rv32im/primitives.png" alt="Synthesized primitives">
    <p style="text-align: center; font-size: 0.9em; color: #666;">
      Synthesis primitives showing DSP and BRAM inference
    </p>

    <h3>Critical Path Analysis</h3>
    <p>
      The longest combinational path determines maximum clock frequency. In this design, it's probably:
    </p>

    <ol>
      <li>PC register output</li>
      <li>Instruction memory read</li>
      <li>Instruction decode</li>
      <li>Register file read</li>
      <li>ALU computation (especially division)</li>
      <li>Data memory access</li>
      <li>Write-back mux</li>
      <li>Register file write</li>
    </ol>

    <p>
      A timing report would show exactly where the bottleneck is. For learning purposes, I didn't optimize for speed—clarity matters more than MHz.
    </p>

    <img src="../images/rv32im/timing_summary.png" alt="Timing summary report">
    <p style="text-align: center; font-size: 0.9em; color: #666;">
      Timing analysis showing critical path
    </p>

    <h2>Physical Implementation</h2>

    <img src="../images/rv32im/fpga_floorplan.png" alt="FPGA floorplan">
    <p style="text-align: center; font-size: 0.9em; color: #666;">
      Physical placement on Artix-7 FPGA showing DSP and BRAM locations
    </p>

    <img src="../images/rv32im/module_hierarchy.png" alt="Module hierarchy">
    <p style="text-align: center; font-size: 0.9em; color: #666;">
      Design module hierarchy
    </p>

    <img src="../images/rv32im/schematic.png" alt="RTL schematic">
    <p style="text-align: center; font-size: 0.9em; color: #666;">
      RTL schematic view of the processor datapath
    </p>

    <img src="../images/rv32im/power_analysis.png" alt="Power analysis">
    <p style="text-align: center; font-size: 0.9em; color: #666;">
      Power consumption breakdown by component
    </p>

    <h2>Testing and Verification</h2>

    <p>
      The current test program is minimal:
    </p>

    <pre><code>immem_block[0] = 32'h00100093;   // addi x1, x0, 1    (x1 = 1)
immem_block[1] = 32'h00108093;   // addi x1, x1, 1    (x1 = x1 + 1)
immem_block[2] = 32'hFFDFF06F;   // jal x0, -4        (jump back to addr 4)</code></pre>

    <p>
      This increments register x1 in an infinite loop. The PC output drives the lower 16 LEDs on the Basys 3 board, so you see the counter incrementing if it's working.
    </p>

    <h3>What Real Verification Looks Like</h3>
    <p>
      A production processor would need thousands of directed tests plus constrained-random generation to hit corner cases. The RISC-V compliance test suite exists for exactly this purpose. Each instruction needs tests for:
    </p>

    <ul>
      <li>Normal operation with typical operands</li>
      <li>Edge cases (zero, negative, overflow)</li>
      <li>Register dependencies (x0 as source/destination)</li>
      <li>Memory alignment (for loads/stores)</li>
      <li>Branch taken/not-taken paths</li>
      <li>Immediate encoding correctness</li>
    </ul>

    <p>
      I built a separate testbench for this core (see my PicoRV32 verification project), but the synthesis success itself is a good sanity check—at least the RTL is structurally sound.
    </p>

    <h2>What I Learned</h2>

    <p><strong>Instruction encoding is more complex than it looks.</strong> RISC-V's immediate packing scheme seems arbitrary until you realize it's optimized for decoder simplicity. Critical bits share positions across instruction formats.</p>

    <p><strong>Hardware multiplication is cheap.</strong> Modern FPGAs have dedicated multipliers. Using them is essentially free compared to LUTs. Don't avoid multiplication in hardware—embrace it.</p>

    <p><strong>Single-cycle designs waste time.</strong> When an ADD instruction completes in 2ns but a LOAD takes 10ns, you're wasting 8ns on every ADD. Pipelining amortizes this cost. But for learning? Single-cycle is perfect.</p>

    <p><strong>Synthesis tools are smart.</strong> Vivado automatically inferred Block RAM for memories, DSP blocks for multipliers, and optimized away unused logic. You write behavioral SystemVerilog, the tools figure out the hardware mapping.</p>

    <p><strong>Debugging is iterative.</strong> The first synthesis run had critical warnings about internal drivers on clock and reset signals. The second run had uninitialized instruction memory. The third run succeeded. Each error teaches you something about what the tools expect.</p>

    <h2>Limitations and Future Work</h2>

    <h3>Current Limitations</h3>
    <ul>
      <li>No pipelining → Low clock frequency</li>
      <li>No caching → Every memory access is slow</li>
      <li>No exceptions/interrupts → Can't handle errors</li>
      <li>No system instructions (ECALL, EBREAK, CSRs)</li>
      <li>Minimal test coverage → Bugs likely exist</li>
      <li>Fixed memory sizes → Can't run real programs</li>
    </ul>

    <h3>Possible Improvements</h3>
    <ul>
      <li><strong>5-stage pipeline:</strong> Fetch, Decode, Execute, Memory, Write-back in separate stages</li>
      <li><strong>Hazard detection:</strong> Handle data dependencies between instructions</li>
      <li><strong>Branch prediction:</strong> Reduce branch penalty</li>
      <li><strong>Cache integration:</strong> I-cache and D-cache for performance</li>
      <li><strong>Exception handling:</strong> Trap on illegal instructions, memory faults</li>
      <li><strong>CSR support:</strong> Control and Status Registers for system management</li>
      <li><strong>UART integration:</strong> Serial I/O for actual program loading</li>
      <li><strong>Compliance testing:</strong> Run official RISC-V test suite</li>
    </ul>

    <h2>Running It Yourself</h2>

    <p>
      The complete source is on GitHub. You'll need:
    </p>

    <ul>
      <li>Xilinx Vivado (free WebPACK edition works)</li>
      <li>Basys 3 board (or any Artix-7 FPGA)</li>
      <li>Constraints file (XDC) for your board</li>
    </ul>

    <p>
      Clone the repo, open the project in Vivado, synthesize, implement, generate bitstream, and program the FPGA. You should see the LEDs counting up as the test program runs.
    </p>

    <h2>Reflections</h2>

    <p>
      Building a CPU from scratch is one of those projects that sounds impossible until you actually do it. The RISC-V ISA specification is only 145 pages. The instruction formats fit on one page. The control logic for a single-cycle implementation is straightforward.
    </p>

    <p>
      What makes it challenging isn't conceptual complexity—it's attention to detail. Getting immediate encodings right. Handling x0 correctly. Making sure branch targets compute properly. Synthesizing cleanly without warnings.
    </p>

    <p>
      But once it works—once you program the FPGA and see those LEDs increment because your handwritten SystemVerilog is executing RISC-V instructions on real hardware—the effort is worth it.
    </p>

    <p>
      Processors aren't magic. They're just state machines with carefully designed control flow. If you understand digital logic and read the ISA spec, you can build one.
    </p>

    <hr style="margin: 3em 0; opacity: 0.3;">

    <p style="opacity: 0.7; font-size: 0.9em;">
      <strong>Source code:</strong> <a href="https://github.com/cigi10/rv32im-core">github.com/yourusername/rv32im-core</a>
    </p>

    <p style="opacity: 0.7; font-size: 0.9em;">
      <strong>References:</strong>
    </p>
    <ul style="opacity: 0.7; font-size: 0.9em;">
      <li>RISC-V ISA Specification v2.2</li>
      <li>Computer Organization and Design: RISC-V Edition (Patterson & Hennessy)</li>
      <li>Xilinx 7 Series FPGAs Data Sheet (DS180)</li>
    </ul>

  </div>
</main>

<footer>
<div class="container"> ∞︎︎ prachi</div>
</footer>
</body>
</html>